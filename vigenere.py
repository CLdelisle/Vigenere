#!/usr/bin/env

'''
A keyed Vignere tool

Python version 2.7

Colby DeLisle
2016
'''

# EVERY LETTER IS UPPERCASE

import argparse
from collections import OrderedDict, deque

def alpha_to_num(char):
	result = ord(char) - 65
	if (result < 0 or result > 25):
		return -1
	else:
		return result

def num_to_alpha(int):
	if   int == 0:
		return 'A'
	elif int == 1:
		return 'B'
	elif int == 2:
		return 'C'
	elif int == 3:
		return 'D'
	elif int == 4:
		return 'E'
	elif int == 5:
		return 'F'
	elif int == 6:
		return 'G'
	elif int == 7:
		return 'H'
	elif int == 8:
		return 'I'
	elif int == 9:
		return 'J'
	elif int == 10:
		return 'K'
	elif int == 11:
		return 'L'
	elif int == 12:
		return 'M'
	elif int == 13:
		return 'N'
	elif int == 14:
		return 'O'
	elif int == 15:
		return 'P'
	elif int == 16:
		return 'Q'
	elif int == 17:
		return 'R'
	elif int == 18:
		return 'S'
	elif int == 19:
		return 'T'
	elif int == 20:
		return 'U'
	elif int == 21:
		return 'V'
	elif int == 22:
		return 'W'
	elif int == 23:
		return 'X'
	elif int == 24:
		return 'Y'
	elif int == 25:
		return 'Z'
	else:
		return ''


def remove_duplicates(list):
	return OrderedDict.fromkeys(''.join(list)).keys()

def first_occurrence(alphabet, char):
	return alphabet.index(char)

def generate_alphabet(key): # takes key as a STRING
	alphabet = list(key)
	for i in range(26):
		alphabet.append(num_to_alpha(i))

	return remove_duplicates(alphabet)

'''
# shifts through normal-ordered alphabet (ABC..Z)
def cyclic_shift(alphabet, offset):
	nums = [alpha_to_num(letter) for letter in alphabet]
	nums = [(n + offset)%26 for n in nums]
	return [num_to_alpha(n) for n in nums]
'''

def rotate_right(alphabet, offset):
	d = deque(alphabet)
	d.rotate(offset)
	return list(d)

def rotate_left(alphabet, offset):
	d = deque(alphabet)
	d.rotate(-offset)
	return list(d)

def tile_keyword(keyword, length):
	key = list(keyword)
	tempkey = key
	num_tiles = (length/len(key)) + 1
	for i in range(num_tiles):
		key = key + tempkey
	return key[:length]

def print_tabula_recta(alphabet):
	for i in range(26):
		print rotate_left(alphabet,i)

# lookup table will be a dictionary
# used to directly translate
# between plaintext & ciphertext
def generate_lookup_table(alphabet, keyword):
	key = list(keyword)
	lookup = {}
	for i in range(len(key)):
		lookup[i] = rotate_left(alphabet, alphabet.index(key[i]))

	return lookup

def decrypt_letter(alphabet, lookup_table, char, index):
	'''
	alphabet - the global alphabet set by the alphakey
	lookup_table - the table generated by the alphakey and keyword
	char - the ciphertext character to decrypt
	index - current state of iteration through the keyword
	'''
	shifted_alphabet = lookup_table[index]
	n = shifted_alphabet.index(char)
	return alphabet[n]


def print_lookup_table(alphabet, keyword): # turn this into generate_lookup_table().. want it as a data structure
	print alphabet
	for i in range(len(keyword)):
		index = first_occurrence(alphabet,keyword[i])
		print(rotate_left(alphabet,index))

parser = argparse.ArgumentParser(description="Encrypt or decrypt a message using a keyed Vignere cipher.")
parser.add_argument('-c', '--cryptmode', choices=['encrypt','decrypt'], default='encrypt')
parser.add_argument('message', help="the message to encrypt or decrypt")
parser.add_argument('alphakey', help="the key with which to generate the alphabet")
parser.add_argument('keyword', help="the keyword with which to generate tabula recta and the lookup table")

args = parser.parse_args()

message = str(args.message).upper()
alphakey = str(args.alphakey).upper()
keyword = str(args.keyword).upper()

alphabet = generate_alphabet(alphakey) # Create alphabet generated by alphakey

key_length = len(list(keyword))

tiled_keyword = tile_keyword(keyword, len(message)) # Tile to match length of alphabet (26)

lookup = generate_lookup_table(alphabet,keyword)

message_chars = list(message)

ciphertext_chars = []

i = 0
for m in message_chars:
	ciphertext_chars.append(decrypt_letter(alphabet, lookup, m, i))
	i = (i + 1) % key_length

print ''
print ''.join(ciphertext_chars)
print ''


